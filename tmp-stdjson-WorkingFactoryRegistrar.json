{"language":"Solidity","sources":{"contracts/IContractRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IContractRegistry {\n    struct Registration {\n        address addr;\n        bytes32 kind;\n        address factory;\n        bytes32 salt;\n        bytes32 initCodeHash;\n        uint64  version;\n        string  label;\n        string  uri;\n    }\n\n    event Registered(\n        bytes32 indexed id,\n        address indexed addr,\n        bytes32 indexed kind,\n        address factory,\n        bytes32 salt,\n        bytes32 initCodeHash,\n        uint64  version,\n        string  label,\n        string  uri\n    );\n\n    function register(Registration calldata r) external returns (bytes32 id);\n}\n"},"contracts/WorkingFactoryRegistrar.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IContractRegistry} from \"./IContractRegistry.sol\";\n\n/// Minimal factory that can deploy via CREATE and then register the\n/// deployed contract in a ContractRegistry. Registry is provided per-call\n/// to avoid coupling and to keep the factory reusable. If `registry` is\n/// address(0), registration is skipped.\ncontract WorkingFactoryRegistrar {\n    event Deployed(address indexed addr, uint256 value);\n\n    error EmptyInitcode();\n    error DeployFailed();\n\n    function deploy(bytes calldata initcode)\n        public\n        payable\n        returns (address addr)\n    {\n        if (initcode.length == 0) revert EmptyInitcode();\n        assembly {\n            let ptr := mload(0x40)\n            let len := initcode.length\n            let off := initcode.offset\n            calldatacopy(ptr, off, len)\n            addr := create(callvalue(), ptr, len)\n        }\n        if (addr == address(0)) revert DeployFailed();\n        emit Deployed(addr, msg.value);\n    }\n\n    /// Deploy and optionally register in a registry that enforces REGISTRAR_ROLE.\n    /// If `registry` == address(0) the register step is skipped.\n    function deployAndRegister(\n        bytes calldata initcode,\n        address registry,\n        bytes32 kind,\n        bytes32 salt,\n        uint64 version,\n        string calldata label,\n        string calldata uri\n    ) external payable returns (address addr, bytes32 id) {\n        addr = this.deploy{value: msg.value}(initcode);\n        if (registry != address(0)) {\n            IContractRegistry.Registration memory r = IContractRegistry.Registration({\n                addr: addr,\n                kind: kind,\n                factory: address(this),\n                salt: salt,\n                initCodeHash: keccak256(initcode),\n                version: version,\n                label: label,\n                uri: uri\n            });\n            id = IContractRegistry(registry).register(r);\n        }\n    }\n}\n\n\n"}},"settings":{"metadata":{"bytecodeHash":"none","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"evmVersion":"paris","outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata","devdoc","userdoc","storageLayout","evm.gasEstimates"],"":["ast"]}}}}